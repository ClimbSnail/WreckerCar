C51 COMPILER V9.54   TIMER                                                                 12/11/2017 20:18:14 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE TIMER
OBJECT MODULE PLACED IN .\Objects\timer.obj
COMPILER INVOKED BY: D:\MDK\C51\BIN\C51.EXE timer.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\t
                    -imer.lst) TABS(2) OBJECT(.\Objects\timer.obj)

line level    source

   1          #include "timer.h"
   2          #include "TB6612.h"
   3          
   4          //定时值的高8位与低8位
   5          static uchar timingValueH[9]= {0xFA,0xFA,0xFE,0xFE,0xFC,0xFA,0xFD,0xFB, 0x00};
   6          static uchar timingValueL[9]= {0x24,0x24,0x0C,0x0C,0x18,0x24,0xDA,0xB3, 0x00};
   7          //   0xF6 0x3C
   8          
   9          //定时器中使用的定时计数值下标
  10          static uchar pwm_flag0 = 0;
  11          static uint pwm_flag1 = 0;
  12          static uchar pwm7H = 0xFB;
  13          static uchar pwm7L = 0xB3;
  14          uchar pos;
  15          
  16          //低电平的剩余时间
  17          static uint timingLeftValue0 = 0;
  18          
  19          static uchar pwm;
  20          //P0对应PWM0~7   目前申明都没用上
  21          sbit pwm0 = P0^0;
  22          sbit pwm1 = P0^1;
  23          sbit pwm2 = P0^2;
  24          sbit pwm3 = P0^3;
  25          sbit pwm4 = P0^4;
  26          sbit pwm5 = P0^5;
  27          sbit pwm6 = P0^6;
  28          sbit pwm7 = P0^7;
  29          
  30          
  31          //定时器0初始化
  32          void timer0_init()
  33          {
  34   1          EA = 1;   //开启总中断
  35   1          ET0 = 1;     // 定时器0可用
  36   1          TMOD |= 0x01;//设置定时器0为工作方式1(16位计数器)
  37   1          //先初始赋值pwm0
  38   1          TH0 = timingValueH[0];
  39   1          TL0 = timingValueL[0];
  40   1          TR0 = 1;//定时器0开始计数
  41   1      }
  42          //定时器1初始化
  43          void timer1_init()
  44          {
  45   1          EA = 1;   //开启总中断
  46   1          ET1 = 1;     // 定时器1可用
  47   1          TMOD |= 0x10;//设置定时器0为工作方式1(16位计数器)
  48   1          //先初始赋值pwm9
  49   1          TH1 = timingValueH[8];
  50   1          TL1 = timingValueL[8];
  51   1          TR1 = 1;//定时器1开始计数
  52   1      }
  53          
  54          //定时器中断0
C51 COMPILER V9.54   TIMER                                                                 12/11/2017 20:18:14 PAGE 2   

  55          void timer0 (void) interrupt 1
  56          {
  57   1      
  58   1          if( pwm_flag0 == 8 )  //当要执行PWM8时
  59   1          {
  60   2              P0 = 0x00;
  61   2              TH0 = timingValueH[8];
  62   2              TL0 = timingValueL[8];
  63   2          }
  64   1          else          //定时PWM0~7
  65   1          {
  66   2              if( pwm_flag0 == 0 )
  67   2                  P0 = 0x01;
  68   2              else
  69   2                  P0 <<= 1;
  70   2              TH0 = timingValueH[pwm_flag0]; //定时时间赋值
  71   2              TL0 = timingValueL[pwm_flag0];
  72   2          }
  73   1          pwm_flag0 = (pwm_flag0+1)%9;  //下标推进
  74   1      }
  75          
  76          //定时器中断1
  77          void timer1 (void) interrupt 3
  78          {
  79   1          TH1 = 0xFC;
  80   1          TL1 = 0x18;
  81   1      //    TH1 = 0xF4;
  82   1      //    TL1 = 0x48;
  83   1          pwm_flag1 = (pwm_flag1+1)%2000;
  84   1          
  85   1          pos = pwm_flag1%10;
  86   1          
  87   1          if( CAR12Speed == pos )
  88   1          {
  89   2            CARPwm1 = 1;
  90   2          }
  91   1          if( CAR34Speed == pos )
  92   1          {
  93   2            CARPwm2 = 1;
  94   2            CARPwm3 = 1;
  95   2          }
  96   1          if( WaterSpeed == pos )
  97   1          {
  98   2            WaterPwm = 1;
  99   2          }
 100   1          if( CleanSpeed == pos )
 101   1          {
 102   2            CleanPwm = 1;
 103   2          }
 104   1          if( LedSpeed == pos )
 105   1          {
 106   2            LEDPwm = 1;
 107   2          }
 108   1          
 109   1          if( pos == 0 )
 110   1          {
 111   2            CARPwm1 = 0;
 112   2            CARPwm2 = 0;
 113   2            CARPwm3 = 0;
 114   2            WaterPwm = 0;
 115   2            CleanPwm = 0;
 116   2            LEDPwm = 0;
C51 COMPILER V9.54   TIMER                                                                 12/11/2017 20:18:14 PAGE 3   

 117   2          }
 118   1          
 119   1          if( pwm_flag1 == 999)
 120   1          {
 121   2            timingValueH[7] = 0xFB;
 122   2            timingValueL[7] = 0xB3;
 123   2            updata_TimingLeft();
 124   2          }
 125   1          if( pwm_flag1 == 1999)
 126   1          {
 127   2            timingValueH[7] = pwm7H;
 128   2            timingValueL[7] = pwm7L;
 129   2            updata_TimingLeft();
 130   2          }
 131   1      }
 132          
 133          
 134          void pwm_change(uchar pwmNumber,uint pwmDuty) //pwmNumber范围0~7 pwmDuty(1~2500us)
 135          {
 136   1          pwmDuty = 65536-pwmDuty;
 137   1      //先改变定时时间的值
 138   1      //  timingValueH[pwmNumber] =  pwmDuty/256;
 139   1      //  timingValueL[pwmNumber] =  pwmDuty%256;
 140   1      //使用位操作,运算速度更快
 141   1          timingValueH[pwmNumber] =  pwmDuty>>8;
 142   1          timingValueL[pwmNumber] =  (pwmDuty<<8)>>8;
 143   1      
 144   1      //  if( pwmNumber == 5 )
 145   1      //    SREET6 = 65536-(timingValueH[5]*256+timingValueL[5]);
 146   1      //  if( pwmNumber == 0 )
 147   1      //    SREET1 = 65536-(timingValueH[0]*256+timingValueL[0]);
 148   1      }
 149          
 150          //更新剩余低电平时间
 151          void updata_TimingLeft()
 152          {
 153   1          uchar count;
 154   1          //计算剩余低电平的剩余时间
 155   1          timingLeftValue0 = 65536-20000;
 156   1          for( count = 0 ; count<8 ; count++ )
 157   1              timingLeftValue0 += ( 65536-(timingValueH[count]*256+timingValueL[count]) );
 158   1          timingValueH[8] = timingLeftValue0>>8;  //更新剩余低电平时间
 159   1          timingValueL[8] = (timingLeftValue0<<8)>>8;
 160   1      }
 161          
 162          int getSteering(int num)
 163          {
 164   1          return 65536-(timingValueH[num]*256+timingValueL[num]);
 165   1      }
 166          
 167          
 168          void set_circle_pwm7(uchar num)//启用pwm7循环转 1为启用 0为关闭
 169          {
 170   1        if( num )
 171   1        {
 172   2          pwm7H = 0xF8;
 173   2          pwm7L = 0xF7;
 174   2        }
 175   1        else
 176   1        {
 177   2          pwm7H = 0xFB;
 178   2          pwm7L = 0xB3;
C51 COMPILER V9.54   TIMER                                                                 12/11/2017 20:18:14 PAGE 4   

 179   2        }
 180   1      }
 181          
 182          void open_Dustbin(uchar num)//开关垃圾箱 1为启用 0为关闭
 183          {
 184   1        if( num )//高电平1500us
 185   1        {
 186   2          timingValueH[6] = 0xFA;
 187   2          timingValueL[6] = 0x24;
 188   2        }
 189   1        else//高电平550us
 190   1        {
 191   2          timingValueH[6] = 0xFD;
 192   2          timingValueL[6] = 0xDA;
 193   2        }
 194   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    630    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     27    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
