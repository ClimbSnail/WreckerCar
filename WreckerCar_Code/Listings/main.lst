C51 COMPILER V9.54   MAIN                                                                  12/11/2017 20:18:13 PAGE 1   


C51 COMPILER V9.54, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\MDK\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings\ma
                    -in.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "60s2.h"
   2          #include "timer.h"
   3          #include "uart.h"
   4          #include "uart2.h"
   5          #include "delay.h"
   6          #include "external.h"
   7          #include "math.h"
   8          #include "action.h"
   9          #include "oled.h"
  10          #include "A4988.h"
  11          #include "TB6612.h"
  12          
  13          #define uchar unsigned char
  14          #define uint  unsigned int
  15          
  16          char FruitFall = 0;
  17          char count = 0;//采摘水果的计数值
  18          int temp;
  19          uchar message = 0x00; //消息
  20          uchar receiveFlag = 0x00;//接收标志
  21          bit busy;
  22          uchar dat[4]= {0,0x80,0x80,0};  //Camera接收的缓冲区
  23          uchar dat_pos = 0;    //串口2数据缓冲器
  24          uchar uart2flag = 0;  //串口2接收标志
  25          //uchar CameraStatus = 0;   //摄像头开启标志
  26          //uchar TCameraStatus = 0;  //摄像头使能状态标志记录
  27          uchar BluetoothLink = 0;  //蓝牙连接标志 蓝牙连接时会发送一串"乱码" 设置标志位用来消除
  28          uchar brightness = 0;
  29          int pwm2;
  30          int pwm3;
  31          
  32          float x=100,z=150;//实际坐标点
  33          
  34          void Uart2() interrupt 8 using 1
  35          {
  36   1          if (S2CON & S2RI)
  37   1          {
  38   2              S2CON &= ~S2RI;     //Clear receive interrupt flag
  39   2              dat[dat_pos] = S2BUF;
  40   2      //    S2BUF = dat[dat_pos];
  41   2              if( dat[dat_pos] == 0xff )
  42   2                  dat_pos = 1;
  43   2              else
  44   2              {
  45   3                  dat_pos++;
  46   3                  if( dat_pos == 4 )
  47   3                      uart2flag = 1;
  48   3                  dat_pos %= 4;
  49   3              }
  50   2          }
  51   1          if (S2CON & S2TI)
  52   1          {
  53   2              S2CON &= ~S2TI;     //Clear transmit interrupt flag
  54   2              busy = 0;           //Clear transmit busy flag
C51 COMPILER V9.54   MAIN                                                                  12/11/2017 20:18:13 PAGE 2   

  55   2          }
  56   1      }
  57          void uart(void) interrupt 4
  58          {
  59   1          if( RI )
  60   1          {
  61   2              RI = 0;  //接收位清零
  62   2              receiveFlag = 1;//接收标志位置1
  63   2              message = SBUF; //接收信息
  64   2              if( message == 0xff )   //蓝牙连接时会发送一串"乱码" 设置标志位用来消除
  65   2              {
  66   3                BluetoothLink = !BluetoothLink;
  67   3                Stop();//车轮停止
  68   3                StopWater();//停止抽水
  69   3                set_circle_pwm7(0);//关闭pwm7循环转
  70   3                StopClean();//停止清洁
  71   3                SetLed(0);//关灯
  72   3              }
  73   2      
  74   2      //以下程序测试用
  75   2      //    SBUF = message;
  76   2      //    while(!TI);     //等待发送数据完成
  77   2      //    TI=0;       //清除发送完成标志位
  78   2          }
  79   1      }
  80          
  81          void Camera_RECEIVE()//摄像头信息处理程序
  82          {
  83   1          
  84   1      }
  85          void RECEIVE_JUGE( )//蓝牙信息处理程序
  86          {
  87   1        if( BluetoothLink )//蓝牙连接时会发送一串"乱码" 设置标志位用来消除
  88   1        {
  89   2          if( receiveFlag == 1 )
  90   2          {
  91   3              switch( message )
  92   3              {
  93   4              case 0x00:         
  94   4                  receiveFlag = 0;
  95   4                  Stop();
  96   4                  break;
  97   4              case 0x01://向前
  98   4                  if( x*x+z*z<=58000 && x<240 && z>0)
  99   4                  {
 100   5                      if( x*x+z*z>=55000 && z>=0.5f)
 101   5                          z -= 0.5f;
 102   5                      x += 0.5f;
 103   5                      Change_angle(x,z);
 104   5                  }
 105   4                  else if( x*x+z*z>58000 && z>0 )
 106   4                      x-=0.5f;
 107   4                  else if( z<=0)
 108   4                  {
 109   5                      z+=0.1f;
 110   5                      pwm2 = 2300+z*10;
 111   5                      pwm3 = 2000+z*10;
 112   5                      pwm_change(2,pwm2);
 113   5                      pwm_change(3,pwm3);
 114   5                      pwm_change(4,2300);
 115   5                  }
 116   4      //      Delay200us();
C51 COMPILER V9.54   MAIN                                                                  12/11/2017 20:18:13 PAGE 3   

 117   4                  break;
 118   4              case 0x02://向后
 119   4                  if( x*x+z*z>=32000 && x>5 && z>0)
 120   4                  {
 121   5                      if( x*x+z*z<=33000 && z<240 )
 122   5                          z += 0.5f;
 123   5                      x-=0.5f;
 124   5                      Change_angle(x,z);
 125   5                  }
 126   4                  else if( x*x+z*z>=32000 && z>0 )
 127   4                      x+=0.5f;
 128   4                  else if( z <= 0 )
 129   4                  {
 130   5                      z-=0.1f;
 131   5                      pwm2 = 2300+z*10;
 132   5                      pwm3 = 2000+z*10;
 133   5                      pwm_change(2,pwm2);
 134   5                      pwm_change(3,pwm3);
 135   5                      pwm_change(4,2300);
 136   5                  }
 137   4      //      Delay200us();
 138   4                  break;
 139   4              case 0x03://向上
 140   4                  if( z>0 )
 141   4                  {
 142   5                      if( x*x+z*z<58000 )
 143   5                      {
 144   6                          if( x*x+z*z>=55000 && x>5 )
 145   6                              x-=0.5f;
 146   6                          z+=0.5f;
 147   6                          Change_angle(x,z);
 148   6                      }
 149   5                      else if( x*x+z*z>=58000 )
 150   5                      {
 151   6                          z-=0.5f;
 152   6                      }
 153   5                  }
 154   4                  else
 155   4                    {
 156   5                      z+=0.1f;
 157   5                      pwm2 = 2300+z*10;
 158   5                      pwm3 = 2000+z*10;
 159   5                      pwm_change(2,pwm2);
 160   5                      pwm_change(3,pwm3);
 161   5                      pwm_change(4,2300);
 162   5                    }
 163   4      //      Delay200us();
 164   4                  break;
 165   4              case 0x04://向下
 166   4                  if( z>0 )
 167   4                  {
 168   5                      if( x*x+z*z>=32000 )
 169   5                      {
 170   6                          if( x*x+z*z<=33000 && x<240)
 171   6                              x+=0.5f;
 172   6                          z-=0.5f;
 173   6                          Change_angle(x,z);
 174   6                      }
 175   5                  }
 176   4                  else
 177   4                    {
 178   5                      z-=0.1f;
C51 COMPILER V9.54   MAIN                                                                  12/11/2017 20:18:13 PAGE 4   

 179   5                      pwm2 = 2300+z*10;
 180   5                      pwm3 = 2000+z*10;
 181   5                      pwm_change(2,pwm2);
 182   5                      pwm_change(3,pwm3);
 183   5                      pwm_change(4,2300);
 184   5                    }
 185   4      //      Delay200us();
 186   4                  break;
 187   4              case 0x05:
 188   4                  temp =  getSteering(5);
 189   4                  if(temp>=2497)pwm_change(5,2497); //逆时针
 190   4                  else
 191   4                    pwm_change(5,temp+1);
 192   4                  updata_TimingLeft();
 193   4                  Delay1ms();
 194   4                  break;
 195   4              case 0x06:
 196   4                  temp =  getSteering(5);
 197   4                  if(temp<=503)pwm_change(5,503); //顺时针
 198   4                  else
 199   4                    pwm_change(5,temp-1);
 200   4                  updata_TimingLeft();
 201   4                  Delay1ms();
 202   4                  break;
 203   4              case 0x07:
 204   4                  temp =  getSteering(0);
 205   4                  if(temp>=1600)pwm_change(0,1600); //夹紧
 206   4                  else
 207   4                    pwm_change(0,temp+1);
 208   4                  updata_TimingLeft();
 209   4                  Delay1ms();
 210   4                  break;
 211   4              case 0x08:
 212   4                  temp =  getSteering(0);
 213   4                  if(temp<=900)
 214   4                    pwm_change(0,900); //松开
 215   4                  else
 216   4                  pwm_change(0,temp-1);
 217   4                  updata_TimingLeft();
 218   4                  Delay1ms();
 219   4                  break;
 220   4              case 0x09://前进
 221   4                  Forward();
 222   4                  Delay100ms();
 223   4                  break;
 224   4              case 0x0a://后退
 225   4                  Back();
 226   4                  Delay100ms();
 227   4                  break;
 228   4              case 0x0b://顺拐
 229   4                  Turnrigth();
 230   4                  Delay100ms();
 231   4                  break;
 232   4              case 0x0c://逆拐
 233   4                  Turnleft();
 234   4                  Delay100ms();
 235   4                  break;
 236   4              case 0x0d://打开水泵
 237   4                  StartWater();
 238   4                  break;
 239   4              case 0x0e://关闭水泵
 240   4                  StopWater();
C51 COMPILER V9.54   MAIN                                                                  12/11/2017 20:18:13 PAGE 5   

 241   4                  break;
 242   4              case 0x0f://开始清洁
 243   4                  StartClean();
 244   4                  break;
 245   4              case 0x10://停止清洁
 246   4                  StopClean();
 247   4                  break;
 248   4              case 0x11:
 249   4                  SetPulsePositive(1000);//铲斗向上
 250   4                  receiveFlag = 0;
 251   4                  break;
 252   4              case 0x12:
 253   4                  SetPulseReverse(1000);//铲斗向下
 254   4                  receiveFlag = 0;
 255   4                  break;
 256   4              case 0x13:
 257   4                  set_circle_pwm7(1);//启用pwm7循环转
 258   4                  receiveFlag = 0;
 259   4                  break;
 260   4              case 0x14:
 261   4                  set_circle_pwm7(0);//关闭pwm7循环转
 262   4                  receiveFlag = 0;
 263   4                  break;
 264   4              case 0x15://开垃圾箱
 265   4                  open_Dustbin(1);//开关垃圾箱 1为启用 0为关闭
 266   4                  receiveFlag = 0;
 267   4                  break;
 268   4              case 0x16://关垃圾箱
 269   4                  open_Dustbin(0);//开关垃圾箱 1为启用 0为关闭
 270   4                  receiveFlag = 0;
 271   4                  break;
 272   4              case 0x17://Led增量一个单位
 273   4                  if( brightness == 1 )
 274   4                    brightness = 1;
 275   4                  else
 276   4                    brightness = (brightness+10-1)%10;
 277   4                  SetLed(brightness);//num为0时关闭 开启的值为1-9,1最大 9最小
 278   4                  receiveFlag = 0;
 279   4                  break;
 280   4              case 0x18://Led减小一个单位
 281   4                  if( brightness == 0 )
 282   4                    brightness = 0;
 283   4                  else
 284   4                    brightness = (brightness+1)%10;
 285   4                  SetLed(brightness);//num为0时关闭 开启的值为1-9,1最大 9最小
 286   4                  receiveFlag = 0;
 287   4                  break;
 288   4              case 0x19://车速调最高
 289   4                SetSpeed(1);//设置速度 值为1-9,1最大 9最小 0时关闭
 290   4                break;
 291   4              case 0x1A://车速调一半
 292   4                SetSpeed(8);//设置速度 值为1-9,1最大 9最小 0时关闭
 293   4                break;
 294   4              default:
 295   4                  break;
 296   4              }
 297   3      
 298   3          }
 299   2        }
 300   1      }
 301          
 302          
C51 COMPILER V9.54   MAIN                                                                  12/11/2017 20:18:13 PAGE 6   

 303          void main() //主程序
 304          {
 305   1          P0 = 0x00;
 306   1          P1 = 0x00;
 307   1          P2 = 0xff;
 308   1          P3 = 0xdf;//步进驱动使能关
 309   1          P4SW |= 0x70;  //启用P4.4 P4.5 P4.6
 310   1        
 311   1          SetLed(0);//num为0时关闭 开启的值为1-9,1最大
 312   1        
 313   1      //    OLED_Init();
 314   1      //    OLED_Clear();
 315   1      //    OLED_ShowCHinese(0,0,9);//辽
 316   1      //    OLED_ShowCHinese(20,0,10);//宁
 317   1      //    OLED_ShowCHinese(40,0,5);//科
 318   1      //    OLED_ShowCHinese(60,0,6);//技
 319   1      //    OLED_ShowCHinese(80,0,11);//大
 320   1      //    OLED_ShowCHinese(100,0,12);//学
 321   1      //    OLED_ShowCHinese(0,4,17);//水
 322   1      //    OLED_ShowCHinese(14,4,18);//果
 323   1      //    OLED_ShowCHinese(28,4,19);//采
 324   1      //    OLED_ShowCHinese(42,4,20);//摘
 325   1      //    OLED_ShowCHinese(56,4,21);//累
 326   1      //    OLED_ShowCHinese(70,4,22);//计
 327   1      //    OLED_ShowChar(84,4,':');
 328   1      //    OLED_ShowNum(92,4,0,3,16);//显示ASCII字符的码值
 329   1          
 330   1          pwm_change(0,900);
 331   1          pwm_change(1,1500);
 332   1          pwm_change(2,1500-90);
 333   1          pwm_change(3,1500-70);
 334   1          pwm_change(4,1500);
 335   1          updata_TimingLeft();//更新剩余低电平时间
 336   1          
 337   1      //    usart_init();
 338   1          uart_init12M(9600); //串口初始化
 339   1          timer0_init();//定时器0初始化
 340   1          timer1_init();//定时器1初始化
 341   1          steering_init();//舵机参数的初始化
 342   1      //    ext0_init();  //外部中断0初始化
 343   1      //    ext1_init();  //外部中断1初始化
 344   1          while(1)
 345   1          {
 346   2              RECEIVE_JUGE();  //串口接收判断
 347   2          }
 348   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2647    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     26    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
